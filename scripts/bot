#!/usr/bin/env python3
import logging
import os
import sys
import typing

from dotenv import load_dotenv
from discord import Member
from discord.ext.commands import NoPrivateMessage
from discord.ext.commands.errors import BadArgument, MissingRequiredArgument, MemberNotFound

sys.path.insert(1, os.path.dirname(os.path.dirname(__file__)))
from erato import *
from erato.model import movesdb

# load our environment
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
LEVEL = getattr(logging, os.getenv('LOG_LEVEL', 'INFO'))

#configure logging
logging.basicConfig(encoding='utf-8', level=LEVEL,
        format='%(asctime)s:%(levelname)s:%(name)s: %(message)s')
logger = logging.getLogger(__name__)

#configure our bot
bot = Bot(command_prefix="!")

@bot.event
async def on_ready():
    logging.info(f'Logged in as {bot.user}')

@bot.check
async def globally_block_dms(ctx):
    if ctx.guild is None:
        raise NoPrivateMessage("This command cannot be used in private messages.")
    return True

@bot.command()
async def roll(ctx, stat: typing.Optional[valid_stat], modifier: typing.Optional[int]):
    msg = ctx.roll(stat, modifier)
    await ctx.send(msg)

@roll.error
async def roll_error(ctx, error):
    if isinstance(error, BadArgument):
        if isinstance(error.__cause__, Invalid):
            await ctx.send(error.__cause__)
    else:
        raise error

@bot.group(aliases=('char', 'ch'))
async def character(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send('Invalid character command passed.')

@character.command()
async def create(ctx):
    try:
        ctx.create_character()
        await ctx.send('Character created!')
    except CharacterExists:
        await ctx.send(f'You already have a character!')

@character.command(aliases=('sheet','sh','st'))
async def stats(ctx, member: Member):
    try:
        msg = f'Stats for {member.nick}:'
        for (stat, value) in ctx.list_stats(member):
            msg += f'\n\t{stat.capitalize()}:\t{value}'
        await ctx.send(msg)
    except Character.DoesNotExist:
        await ctx.send(f"You don't have a character yet!")

@character.command()
async def set(ctx, stat: valid_stat, value: int):
    try:
        ctx.set_character_attribute(stat, value)
        await ctx.send(f'Set!')

    except Character.DoesNotExist:
        await ctx.send(f"You don't have a character yet!")

@set.error
async def set_error(ctx, error):
    if isinstance(error, BadArgument):
        if isinstance(error.__cause__, Invalid):
            await ctx.send(error.__cause__)
        else:
            await ctx.send(f'Value must be an integer.')
    else:
        raise error

@bot.group(aliases=('st',))
async def strings(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send('Invalid strings command passed.')

@strings.command()
async def give(ctx, owner: Member):
    try:
        total = ctx.give_string(owner)
        strings = 'strings'
        if total == 1:
            strings = 'string'
        await ctx.send(f'{owner.nick} now has {total} {strings} on {ctx.message.author.nick}.')
    except Character.DoesNotExist:
        await ctx.send('You both need to have characters to give a string.')

@strings.command()
async def spend(ctx, target: Member):
    try:
        total = ctx.spend_string(target)
        strings = 'strings'
        if total == 1:
            strings = 'string'
        await ctx.send(f'String spent! {ctx.message.author.nick} now has {total} {strings} on {target.nick}.')
    except Character.DoesNotExist:
        await ctx.send('You both need to have characters to spend a string.')
    except NoStrings:
        await ctx.send(f'You do not have strings on {target.nick}.')

@strings.command(aliases=('ls','l','look'))
async def list(ctx, owner: Member):
    msg = f'Strings for {owner.nick}:'
    for (member, count) in ctx.list_strings(owner):
        if member is None:
            member = ctx.message.author
        msg += f'\n\t{member.nick}:\t{count}'
    await ctx.send(msg)

@list.error
async def strings_error(ctx, error):
    if isinstance(error, MissingRequiredArgument):
        await ctx.send('Whose strings do you want to see?')
    elif isinstance(error, MemberNotFound):
        await ctx.send(error)
    else:
        raise error

@bot.group()
async def xp(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send('Invalid xp command passed.')

@xp.command(aliases=('l',))
async def look(ctx, member: Member):
    char = ctx.character(member)
    await ctx.send(f'{member.nick} has {char.xp} XP.')

@xp.command(aliases=('a','g','give'))
async def award(ctx, member: Member):
    xp = ctx.award_xp(member)
    await ctx.send(f'Awarded XP! {member.nick} now has {xp} XP.')

@xp.command(aliases=('r','z','zero'))
async def reset(ctx, member: Member):
    ctx.reset_xp(member)
    await ctx.send(f"{member.nick}'s XP reset to zero.")

@bot.group()
async def moves(ctx):
    if ctx.invoked_subcommand is None:
        await ctx.send('Invalid moves command passed.')

@moves.command()
async def list(ctx, move: typing.Optional[str]):
    if move is None:
        list = '\n\t'.join(sorted(k.title() for k in model.movesdb.moves))
        await ctx.send(f"""```
!moves list [move]

Use this command with the name of a move to see the listing for that move. You do not have to provide the entire move name, just a word that is unique to it (e.g. '!moves list advance' for 'String Advance'). You can also quote the entire name (e.g. '!moves list "end of session"').

Available moves: \n\t{list}```""")
    else:
        moveKey = None
        for key in movesdb.moves:
            if move.lower() in key.lower():
                moveKey = key
                break
        if moveKey is None:
            await ctx.send('Invalid move.')
            return
        m = movesdb.moves[moveKey]
        parts = [m['description']]
        if m.get('up') is not None:
            parts.append(f"(10+): {m['up']}")
        if m.get('mixed') is not None:
            parts.append(f"(7-9): {m['mixed']}")
        if m.get('all') is not None:
            parts.append(f"{m['all']}")
        text = "\n".join(parts)
        await ctx.send(f'```{text}```')



# run
bot.run(TOKEN)
